Turn a YouTube channel into a second brain with Neo4j GraphRAG and GPT-4o-mini

https://n8nworkflows.xyz/workflows/turn-a-youtube-channel-into-a-second-brain-with-neo4j-graphrag-and-gpt-4o-mini-12812


# Turn a YouTube channel into a second brain with Neo4j GraphRAG and GPT-4o-mini

## 1. Workflow Overview

**Purpose:**  
This n8n workflow turns a YouTube channel into a ‚Äúsecond brain‚Äù by (1) ingesting videos from a channel using Apify, (2) extracting structured entities (topics, tools, concepts) from title/description/transcript using an LLM (GPT‚Äë4o‚Äëmini via OpenRouter), (3) storing the resulting knowledge graph in **Neo4j Aura**, and (4) providing a **chat-based AI agent** that answers questions by generating **Cypher** queries against Neo4j (GraphRAG pattern).

**Target use cases:**
- Build a searchable knowledge graph of a creator‚Äôs content (business/entrepreneurship/tech)
- Ask natural-language questions like ‚ÄúWhich videos talk about Shopify + ecommerce?‚Äù
- Discover frequently mentioned tools/topics/concepts across the channel

### 1.1 Channel & Video Ingestion (Apify)
Collects a channel‚Äôs video URLs, loops through them, and scrapes details (including subtitles/transcripts).

### 1.2 Entity Extraction (LLM ‚Üí Structured JSON)
Checks required fields exist, then runs an LLM ‚Äúextractor‚Äù agent to produce a JSON object with `topics`, `tools`, `concepts`, validated/fixed by a structured output parser.

### 1.3 Persist to Neo4j (Graph Construction)
Upserts `Video` nodes and connects them to `Topic`, `Tool`, `Concept` nodes via `COVERS`, `USES`, `EXPLAINS`.

### 1.4 Completion Screen (Form Completion)
Shows a completion message once processing is done (notably: current wiring may display completion before ingestion truly finishes; see edge cases).

### 1.5 Conversational GraphRAG Agent (Chat ‚Üí Cypher ‚Üí Answer)
Receives chat messages, uses an LLM agent with a Neo4j ‚Äútool‚Äù (HTTP Request Tool) to run Cypher and respond with linked video recommendations.

---

## 2. Block-by-Block Analysis

### Block 1 ‚Äî Scrape Channel & Video URLs (Apify)
**Overview:**  
Collects a list of videos from a provided YouTube channel URL, then iterates through each video URL for deeper scraping.

**Nodes involved:**
- `Wich creator ? How many videos ?` (Form Trigger)
- `Get channel videos URLs` (Apify)
- `loop each video` (Split in Batches)

#### Node: Wich creator ? How many videos ?
- **Type / role:** `Form Trigger` ‚Äî interactive input entry point for ingestion.
- **Configuration (interpreted):**
  - Form title: ‚ÄúQuel youtubeur veux tu cloner ?‚Äù
  - Fields:
    - `URL` (required)
    - `Nombre de vid√©os √† r√©cup√©rer ?` (number, required; placeholder ‚Äú1000‚Äù)
  - Description: ‚ÄúInput l'URL de sa cha√Æne YouTube ci dessous.‚Äù
- **Outputs:** To `Get channel videos URLs`.
- **Edge cases / failures:**
  - Invalid channel URL ‚Üí Apify may return empty dataset or errors.
  - Very large number of requested videos ‚Üí long runtime and higher costs/timeouts downstream.

#### Node: Get channel videos URLs
- **Type / role:** `Apify` node (`Run actor and get dataset`) ‚Äî fetches channel video list.
- **Configuration (interpreted):**
  - Actor: **YouTube Scraper (streamers/youtube-scraper)** (`h7sDV53CddomktSi5`)
  - Key input settings:
    - `startUrls[0].url` = form `URL`
    - `maxResults` = form `Nombre de vid√©os √† r√©cup√©rer ?`
    - `sortingOrder: "views"` (fetches by views)
    - `dateFilter: "year"`
    - `downloadSubtitles: true`, `preferAutoGeneratedSubtitles: true`
    - `subtitlesLanguage: "fr"`, `subtitlesFormat: "plaintext"`
    - `videoType: "video"` (no shorts)
- **Credentials:** Apify API token (`Apify account`).
- **Outputs:** To `loop each video`.
- **Edge cases / failures:**
  - Apify actor throttling / quota exceeded.
  - Channel pages with restrictions (age/region) may reduce results.
  - Subtitles may be missing even with preferences set.

#### Node: loop each video
- **Type / role:** `SplitInBatches` ‚Äî iterates over video URLs from the dataset.
- **Configuration (interpreted):**
  - Uses default batch settings (not explicitly set in JSON).
- **Connections:**
  - Output 1 ‚Üí `Results`
  - Output 1 ‚Üí `Scraping of each URLs`
- **Important behavior note:**  
  The node is connected to `Results` (completion screen) and to `Scraping of each URLs` in parallel. In many executions, `Results` may receive items early (or before full loop completion), depending on how batches are handled.
- **Edge cases / failures:**
  - If batch size not controlled, may create concurrency pressure on Apify/LLM/Neo4j.
  - If upstream dataset items don‚Äôt contain `url`, the next Apify scrape will fail.

---

### Block 2 ‚Äî Scrape Each Video Details (Apify)
**Overview:**  
For each video URL, fetches full metadata and subtitles/transcript in French.

**Nodes involved:**
- `Scraping of each URLs` (Apify)

#### Node: Scraping of each URLs
- **Type / role:** `Apify` node (`Run actor and get dataset`) ‚Äî scrapes per-video details.
- **Configuration (interpreted):**
  - Actor: same YouTube Scraper (`h7sDV53CddomktSi5`)
  - `startUrls[0].url` = current item‚Äôs `{{$json.url}}`
  - `maxResults: 10` (note: this is hard-coded; for a single video URL it‚Äôs likely fine, but it can still return multiple items depending on actor behavior)
  - Same subtitle preferences: download, auto-generated preferred, `fr`, `plaintext`
- **Error handling:** `onError: continueRegularOutput` (workflow continues even if scraping fails).
- **Outputs:** To `If`.
- **Edge cases / failures:**
  - Some videos have no subtitles ‚Üí `subtitles[0].plaintext` missing later.
  - Actor may return multiple entries; downstream assumes a single structure (title/text/subtitles[0]).
  - Because errors continue, you can get partial/malformed items that fail later.

---

### Block 3 ‚Äî Validate Required Fields
**Overview:**  
Ensures title, description, and transcript exist before LLM extraction.

**Nodes involved:**
- `If` (n8n If)

#### Node: If
- **Type / role:** `If` ‚Äî gate before entity extraction.
- **Configuration (interpreted):**
  - Checks all of these ‚Äúexist‚Äù:
    - `{{$json.title}}`
    - `{{$json.text || $json.translatedText}}`
    - `{{$json.subtitles[0].plaintext}}`
- **Connections:**
  - **True** ‚Üí `Cat√©gorie d√©finition Agent`
  - **False** ‚Üí `loop each video` (skips extraction/storage and moves loop forward)
- **Edge cases / failures:**
  - If `subtitles` is undefined, the expression `$json.subtitles[0].plaintext` can error depending on n8n expression evaluation; often it becomes `undefined`, but in strict contexts it may throw.
  - Videos without subtitles/transcripts are effectively skipped.

---

### Block 4 ‚Äî Extract Topics/Tools/Concepts as Structured JSON (LLM)
**Overview:**  
Uses a LangChain Agent configured as an entity extractor to produce valid JSON containing normalized lists of topics/tools/concepts.

**Nodes involved:**
- `Cat√©gorie d√©finition Agent` (LangChain Agent)
- `4o mini` (OpenRouter chat model)
- `sonnet 3.5` (OpenRouter chat model; fallback/alternate)
- `Parseur` (Structured Output Parser)
- `4.1 mini` (OpenRouter chat model used by parser auto-fix)

#### Node: 4o mini
- **Type / role:** `lmChatOpenRouter` ‚Äî primary LLM for extraction.
- **Configuration (interpreted):**
  - Model: `openai/gpt-4o-mini`
  - Temperature: `0.1` (low variance; consistent JSON)
- **Connection:** provides `ai_languageModel` to `Cat√©gorie d√©finition Agent`.
- **Credentials:** OpenRouter (`OpenRouter account - Hugo`).
- **Edge cases / failures:**
  - Rate limits / billing issues on OpenRouter.
  - Model may still produce malformed JSON ‚Üí handled by output parser with autofix.

#### Node: sonnet 3.5
- **Type / role:** `lmChatOpenRouter` ‚Äî alternate/fallback model.
- **Configuration:** `anthropic/claude-3.5-sonnet`
- **Connection:** `ai_languageModel` to `Cat√©gorie d√©finition Agent` (index 1).
- **Edge cases:** same as above; model differences may impact normalization or language.

#### Node: Parseur
- **Type / role:** `outputParserStructured` ‚Äî enforces a JSON schema-like structure.
- **Configuration (interpreted):**
  - `autoFix: true` ‚Äî attempts to repair invalid output.
  - Provides an example schema with `topics/tools/concepts` arrays.
- **Connection:** `ai_outputParser` ‚Üí `Cat√©gorie d√©finition Agent`.
- **LLM for autofix:** uses `4.1 mini` as the parser‚Äôs language model.
- **Edge cases / failures:**
  - If the LLM output is too far from expected structure, autofix may fail.
  - If extractor returns non-French characters or weird casing, normalization is expected in prompt, not enforced by parser.

#### Node: 4.1 mini
- **Type / role:** `lmChatOpenRouter` ‚Äî LLM used for parser auto-fix.
- **Configuration:** options empty (defaults); model name not explicitly set in parameters (node name implies ‚Äú4.1 mini‚Äù, but OpenRouter model field is not configured here).
- **Connection:** `ai_languageModel` ‚Üí `Parseur`.
- **Edge cases / failures:**
  - Missing `model` parameter may rely on node defaults; if n8n/OpenRouter requires explicit model selection, this can break.
  - Safer: set an explicit model in node parameters.

#### Node: Cat√©gorie d√©finition Agent
- **Type / role:** `@n8n/n8n-nodes-langchain.agent` ‚Äî extraction agent producing JSON.
- **Configuration (interpreted):**
  - Prompt input text:
    - Title: `{{$json.title}}`
    - Description: `{{$json.text || $json.translatedText}}`
    - Transcript: `{{$json.subtitles[0].plaintext}}`
  - System message: French instructions to extract:
    - `topics`: themes
    - `tools`: software/services
    - `concepts`: methods/models/strategies
  - Rules:
    - only explicitly mentioned
    - lowercase, no duplicates, max 15 per category, prioritize important
  - Output: ‚ÄúJSON valid only‚Äù
  - `needsFallback: true`, `hasOutputParser: true`
- **Inputs:**
  - Main: from `If` true branch
  - AI language models: from `4o mini` (primary) and `sonnet 3.5` (secondary)
  - Output parser: from `Parseur`
- **Outputs:** to `Vers Neo4j`
- **Edge cases / failures:**
  - If transcript is huge, context length issues (token limits) may truncate analysis.
  - If `translatedText` exists but is not French, extraction may include non-normalized forms unless prompt handles it.

---

### Block 5 ‚Äî Insert/Upsert into Neo4j (Graph Build)
**Overview:**  
Sends a Cypher statement to Neo4j Aura via HTTP to upsert the video and connect it to topic/tool/concept nodes.

**Nodes involved:**
- `Vers Neo4j` (HTTP Request)

#### Node: Vers Neo4j
- **Type / role:** `HTTP Request` ‚Äî writes to Neo4j transactional query endpoint.
- **Configuration (interpreted):**
  - POST to: `https://4b095dfe.databases.neo4j.io/db/neo4j/query/v2`
  - Auth: `HTTP Header Auth` credential (‚ÄúNeo4j‚Äù) using `Authorization: Basic <base64>`
  - JSON body contains:
    - `statement`: Cypher `MERGE` on `(v:Video {videoId: $videoId})`, sets properties, then `UNWIND` arrays to create/merge `Topic`, `Tool`, `Concept` nodes and relationships:
      - `(v)-[:COVERS]->(t:Topic)`
      - `(v)-[:USES]->(tool:Tool)`
      - `(v)-[:EXPLAINS]->(c:Concept)`
    - `parameters`: values mapped from `Scraping of each URLs` item plus extracted arrays:
      - `videoId`, `title`, `url`, `publishedAt`, `viewCount`, `duration`, `channelName`
      - `topics/tools/concepts` are `JSON.stringify($json.output.<...>)`
  - Headers: `Accept: application/json`
- **Error handling:** `onError: continueErrorOutput` (continue even if Neo4j write fails).
- **Outputs:** back to `loop each video` (two connections shown; effectively it advances the loop).
- **Edge cases / failures:**
  - **Auth misconfiguration** (most common): wrong base64, wrong header name/value.
  - Neo4j endpoint expects strict JSON; if expressions produce invalid JSON (e.g., `viewCount` undefined), request can fail.
  - Relationship duplication is prevented via `MERGE`, but note that topic/tool/concept names are taken as-is from LLM; prompt enforces lowercase but not guaranteed.
  - If `Scraping of each URLs` returns multiple items per URL, `$('Scraping of each URLs').item.json...` may not reference the intended item in multi-item contexts.

---

### Block 6 ‚Äî Completion Screen
**Overview:**  
Shows a form ‚Äúcompletion‚Äù page indicating the second brain is created.

**Nodes involved:**
- `Results` (Form ‚Äúcompletion‚Äù)

#### Node: Results
- **Type / role:** `Form` node with operation `completion`.
- **Configuration (interpreted):**
  - Completion title: `Votre deuxi√®me cerveau bas√© sur {{ $json.channelName }} √† √©t√© cr√©√© avec succ√®s !`
  - Completion message: ‚ÄúTu peux maintenant discuter avec un Agent IA entrain√© sur le data de sa cha√Æne Youtube.‚Äù
- **Input:** from `loop each video`.
- **Edge cases / failures:**
  - Because it‚Äôs connected directly from the loop, the completion screen may appear **before** all videos are fully processed (depending on SplitInBatches behavior and batching).
  - `$json.channelName` may not exist at that stage (if the loop item is only a URL record rather than detailed scrape output), resulting in an empty title.

---

### Block 7 ‚Äî Chat Agent (GraphRAG: Ask Neo4j with Tool Use)
**Overview:**  
Provides an interactive agent: it receives a chat message, generates Cypher using a Neo4j tool, executes it, and responds with linked video recommendations in French.

**Nodes involved:**
- `When chat message received` (Chat Trigger)
- `AI Agent` (LangChain Agent)
- `neo4j_query` (HTTP Request Tool)
- `Simple Memory` (Memory)
- `4o` (OpenRouter LLM)
- `sonnet 4.5` (OpenRouter LLM alternate)
- `Respond to Chat` (Chat Response)

#### Node: When chat message received
- **Type / role:** `chatTrigger` ‚Äî chat entry point.
- **Configuration:** response mode `responseNodes` (responses come from response nodes).
- **Outputs:** to `AI Agent`.
- **Edge cases:**
  - If chat UI or webhook not correctly configured, messages won‚Äôt trigger.

#### Node: 4o
- **Type / role:** `lmChatOpenRouter` ‚Äî primary chat reasoning model for the agent.
- **Configuration:**
  - Model: `openai/chatgpt-4o-latest`
  - Temperature: `0.1`
- **Connection:** `ai_languageModel` ‚Üí `AI Agent` (index 0).
- **Edge cases:** OpenRouter availability/rate limits.

#### Node: sonnet 4.5
- **Type / role:** `lmChatOpenRouter` ‚Äî secondary model for the agent.
- **Configuration:** `anthropic/claude-sonnet-4.5`
- **Connection:** `ai_languageModel` ‚Üí `AI Agent` (index 1).

#### Node: Simple Memory
- **Type / role:** `memoryBufferWindow` ‚Äî keeps short chat context.
- **Configuration:** `contextWindowLength: 10` (last 10 turns).
- **Connection:** `ai_memory` ‚Üí `AI Agent`.
- **Edge cases:** Memory only exists per session; doesn‚Äôt persist across separate chat sessions unless configured otherwise.

#### Node: neo4j_query
- **Type / role:** `httpRequestTool` ‚Äî tool callable by the agent to run Cypher.
- **Configuration (interpreted):**
  - POST to Neo4j endpoint `.../query/v2`
  - Auth: HTTP Header Auth (`Authorization: Basic <base64>`)
  - Header: `Content-Type: Application/json` (note capitalization; generally acceptable, but standard is `application/json`)
  - Body: generated by AI (`$fromAI('JSON', ..., 'json')`) with format:
    - `{ "statement": "CYPHER..." }`
- **Connection:** exposed as `ai_tool` to `AI Agent`.
- **Edge cases / failures:**
  - If the agent produces invalid JSON for the tool body, request fails.
  - If the agent writes Cypher returning unexpected columns, the final natural-language answer may degrade.
  - Neo4j Aura endpoint/network failures.

#### Node: AI Agent
- **Type / role:** `langchain.agent` ‚Äî orchestrates tool use and final answer.
- **Configuration (interpreted):**
  - System message (French) defines:
    - Graph schema (Video/Topic/Tool/Concept + relations)
    - How to call `neo4j_query` with `{ "statement": "..." }`
    - Query examples
    - Rules: always `toLower()` + `CONTAINS`, limit 10, return `title` and `url`, respond in French, format links as `[Title](url)`, suggest alternates if none.
  - `needsFallback: true` (can use alternate model).
- **Inputs:**
  - Main: from `When chat message received`
  - AI language models: `4o` and `sonnet 4.5`
  - Tool: `neo4j_query`
  - Memory: `Simple Memory`
- **Outputs:** to `Respond to Chat`.
- **Edge cases / failures:**
  - If Neo4j is empty (ingestion not run or failed), answers will always be ‚Äúno result.‚Äù
  - If naming normalization differs (e.g., ‚Äúchat gpt‚Äù vs ‚Äúchatgpt‚Äù), `CONTAINS` helps but is not perfect.

#### Node: Respond to Chat
- **Type / role:** `chat` ‚Äî sends response back to chat client.
- **Configuration:** message = `{{$json.output}}` (expects agent output in `output`).
- **Edge cases:**
  - If agent returns a different key or tool errors produce no `output`, message may be blank.

---

## 3. Summary Table

| Node Name | Node Type | Functional Role | Input Node(s) | Output Node(s) | Sticky Note |
|---|---|---|---|---|---|
| Wich creator ? How many videos ? | n8n-nodes-base.formTrigger | Collect channel URL and number of videos | ‚Äî | Get channel videos URLs | # GraphRAG with Neo4j \| Second Brain YouTube / Setup steps / Customization (see full note content) |
| Get channel videos URLs | @apify/n8n-nodes-apify.apify | Scrape channel to obtain video URLs dataset | Wich creator ? How many videos ? | loop each video | ## üì• Video Ingestion\nScrapes YouTube videos via Apify, extracts entities with GPT-4o-mini, and stores everything in Neo4j. |
| loop each video | n8n-nodes-base.splitInBatches | Iterate through video URLs | Get channel videos URLs; Vers Neo4j; If (false) | Results; Scraping of each URLs | ## üì• Video Ingestion\nScrapes YouTube videos via Apify, extracts entities with GPT-4o-mini, and stores everything in Neo4j. |
| Scraping of each URLs | @apify/n8n-nodes-apify.apify | Scrape each video details + subtitles | loop each video | If | ## 1. Scrape Channel & Video URLs\nFetches the YouTube channel and retrieves all video URLs using Apify YouTube Scraper. |
| If | n8n-nodes-base.if | Validate title/description/transcript exist | Scraping of each URLs | Cat√©gorie d√©finition Agent (true); loop each video (false) | ## 2. Extract Concepts, Tools, Topics\nLLM analyzes title, description & transcript to extract structured entities (Topics, Tools, Concepts) as JSON. |
| Cat√©gorie d√©finition Agent | @n8n/n8n-nodes-langchain.agent | Entity extraction to JSON (topics/tools/concepts) | If (true) | Vers Neo4j | ## 2. Extract Concepts, Tools, Topics\nLLM analyzes title, description & transcript to extract structured entities (Topics, Tools, Concepts) as JSON. |
| 4o mini | @n8n/n8n-nodes-langchain.lmChatOpenRouter | Primary LLM for extraction | ‚Äî | Cat√©gorie d√©finition Agent (AI model) | ## 2. Extract Concepts, Tools, Topics\nLLM analyzes title, description & transcript to extract structured entities (Topics, Tools, Concepts) as JSON. |
| sonnet 3.5 | @n8n/n8n-nodes-langchain.lmChatOpenRouter | Secondary LLM for extraction | ‚Äî | Cat√©gorie d√©finition Agent (AI model) | ## 2. Extract Concepts, Tools, Topics\nLLM analyzes title, description & transcript to extract structured entities (Topics, Tools, Concepts) as JSON. |
| Parseur | @n8n/n8n-nodes-langchain.outputParserStructured | Enforce/fix structured JSON output | ‚Äî | Cat√©gorie d√©finition Agent (output parser) | ## 2. Extract Concepts, Tools, Topics\nLLM analyzes title, description & transcript to extract structured entities (Topics, Tools, Concepts) as JSON. |
| 4.1 mini | @n8n/n8n-nodes-langchain.lmChatOpenRouter | LLM used by parser auto-fix | ‚Äî | Parseur (AI model) | ## 2. Extract Concepts, Tools, Topics\nLLM analyzes title, description & transcript to extract structured entities (Topics, Tools, Concepts) as JSON. |
| Vers Neo4j | n8n-nodes-base.httpRequest | Upsert graph data into Neo4j | Cat√©gorie d√©finition Agent | loop each video | ## 3. Input into Neo4j database\nSends extracted data to Neo4j, creating Video nodes and relationships to Topics, Tools, and Concepts. |
| Results | n8n-nodes-base.form | Show completion message | loop each video | ‚Äî | ## 4. Show completion screen |
| When chat message received | @n8n/n8n-nodes-langchain.chatTrigger | Chat entry point for QA | ‚Äî | AI Agent | ## 5. ü§ñ Ask the Database for relation with LLM augmented analysis\nReceives user questions, generates Cypher queries via the Neo4j tool, and returns a natural response with relevant videos. |
| AI Agent | @n8n/n8n-nodes-langchain.agent | GraphRAG agent (writes Cypher via tool, responds in French) | When chat message received | Respond to Chat | ## 5. ü§ñ Ask the Database for relation with LLM augmented analysis\nReceives user questions, generates Cypher queries via the Neo4j tool, and returns a natural response with relevant videos. |
| 4o | @n8n/n8n-nodes-langchain.lmChatOpenRouter | Primary LLM for chat agent | ‚Äî | AI Agent (AI model) | ## 5. ü§ñ Ask the Database for relation with LLM augmented analysis\nReceives user questions, generates Cypher queries via the Neo4j tool, and returns a natural response with relevant videos. |
| sonnet 4.5 | @n8n/n8n-nodes-langchain.lmChatOpenRouter | Secondary LLM for chat agent | ‚Äî | AI Agent (AI model) | ## 5. ü§ñ Ask the Database for relation with LLM augmented analysis\nReceives user questions, generates Cypher queries via the Neo4j tool, and returns a natural response with relevant videos. |
| Simple Memory | @n8n/n8n-nodes-langchain.memoryBufferWindow | Keeps last 10 messages context | ‚Äî | AI Agent (memory) | ## 5. ü§ñ Ask the Database for relation with LLM augmented analysis\nReceives user questions, generates Cypher queries via the Neo4j tool, and returns a natural response with relevant videos. |
| neo4j_query | n8n-nodes-base.httpRequestTool | Tool for agent to execute Cypher via HTTP | ‚Äî | AI Agent (tool) | ##  ‚ö†Ô∏è Credentials\nMake sure you converted your username:password combination into a Base64 string.\nYou can use this site : [Base64 Encode](https://www.base64encode.org/) |
| Respond to Chat | @n8n/n8n-nodes-langchain.chat | Returns agent output to chat | AI Agent | ‚Äî | ## 5. ü§ñ Ask the Database for relation with LLM augmented analysis\nReceives user questions, generates Cypher queries via the Neo4j tool, and returns a natural response with relevant videos. |
| Sticky Note | n8n-nodes-base.stickyNote | Canvas note (Video ingestion) | ‚Äî | ‚Äî | ## üì• Video Ingestion\nScrapes YouTube videos via Apify, extracts entities with GPT-4o-mini, and stores everything in Neo4j. |
| Sticky Note1 | n8n-nodes-base.stickyNote | Canvas note (Chat agent) | ‚Äî | ‚Äî | ## 5. ü§ñ Ask the Database for relation with LLM augmented analysis\nReceives user questions, generates Cypher queries via the Neo4j tool, and returns a natural response with relevant videos. |
| Sticky Note2 | n8n-nodes-base.stickyNote | Canvas note (Overall setup) | ‚Äî | ‚Äî | # GraphRAG with Neo4j \| Second Brain YouTube (setup/customization text) |
| Sticky Note3 | n8n-nodes-base.stickyNote | Canvas note (Neo4j auth) | ‚Äî | ‚Äî | ##  ‚ö†Ô∏è Credentials ‚Ä¶ [Base64 Encode](https://www.base64encode.org/) |
| Sticky Note4 | n8n-nodes-base.stickyNote | Canvas note (Scrape step) | ‚Äî | ‚Äî | ## 1. Scrape Channel & Video URLs ‚Ä¶ |
| Sticky Note5 | n8n-nodes-base.stickyNote | Canvas note (Extraction step) | ‚Äî | ‚Äî | ## 2. Extract Concepts, Tools, Topics ‚Ä¶ |
| Sticky Note6 | n8n-nodes-base.stickyNote | Canvas note (Neo4j step) | ‚Äî | ‚Äî | ## 3. Input into Neo4j database ‚Ä¶ |
| Sticky Note7 | n8n-nodes-base.stickyNote | Canvas note (Completion) | ‚Äî | ‚Äî | ## 4. Show completion screen |
| Sticky Note8 | n8n-nodes-base.stickyNote | Canvas note (Outputs + dashboard images) | ‚Äî | ‚Äî | ## üìä Output - Neo4j Dashboard & AI Chat\n![Dashboard Preview](https://bdcahdjartshknrvdnxq.supabase.co/storage/v1/object/public/gpt-images/neo4j_dash_1.png)\n![Dashboard Preview](https://bdcahdjartshknrvdnxq.supabase.co/storage/v1/object/public/gpt-images/neo4j-dash-2.png) |

---

## 4. Reproducing the Workflow from Scratch

### Prerequisites
1. **Neo4j AuraDB** instance (free tier is sufficient).
2. **Apify** account + API token.
3. **OpenRouter** account + API key (to use GPT‚Äë4o‚Äëmini and optionally Claude models).
4. In n8n, install/enable:
   - Apify node (`@apify/n8n-nodes-apify`)
   - LangChain nodes (`@n8n/n8n-nodes-langchain`)

### A) Credentials setup
1. **Apify credential**
   - Create credential: *Apify API*
   - Paste your Apify token.

2. **OpenRouter credential**
   - Create credential: *OpenRouter API*
   - Paste OpenRouter API key.

3. **Neo4j HTTP Header Auth credential**
   - In Neo4j Aura, obtain DB username and password.
   - Create a Base64 of `username:password`.
   - Create credential: *HTTP Header Auth*
     - Header name: `Authorization`
     - Header value: `Basic <your_base64_string>`
   - (Optional) Verify also that requests send `Content-Type: application/json`.

### B) Build the ingestion pipeline (Form ‚Üí Apify ‚Üí Loop ‚Üí Apify ‚Üí If ‚Üí LLM ‚Üí Neo4j)
1. **Add node: Form Trigger**
   - Node type: *Form Trigger*
   - Title: ‚ÄúQuel youtubeur veux tu cloner ?‚Äù
   - Description: ‚ÄúInput l'URL de sa cha√Æne YouTube ci dessous.‚Äù
   - Fields:
     - `URL` (required)
     - `Nombre de vid√©os √† r√©cup√©rer ?` (type number, required, placeholder ‚Äú1000‚Äù)

2. **Add node: Apify (Get channel videos URLs)**
   - Node type: *Apify*
   - Operation: *Run actor and get dataset*
   - Actor: `streamers/youtube-scraper`
   - Custom input body:
     - `startUrls: [{ url: {{$json.URL}} }]`
     - `maxResults: {{$json['Nombre de vid√©os √† r√©cup√©rer ? ']}}`
     - `sortingOrder: "views"`, `dateFilter: "year"`
     - `downloadSubtitles: true`, `preferAutoGeneratedSubtitles: true`
     - `subtitlesLanguage: "fr"`, `subtitlesFormat: "plaintext"`
     - `videoType: "video"`
   - Select Apify credential.

3. **Add node: Split In Batches (loop each video)**
   - Node type: *SplitInBatches*
   - Keep defaults (or set a safe batch size, e.g. 1‚Äì5, to control load).

4. **Add node: Apify (Scraping of each URLs)**
   - Node type: *Apify*
   - Operation: *Run actor and get dataset*
   - Actor: `streamers/youtube-scraper`
   - Custom input body:
     - `startUrls: [{ url: {{$json.url}} }]`
     - Subtitle options same as above
     - `maxResults: 10` (or set to 1 if you want strictly one record per URL)
   - Set node ‚ÄúOn Error‚Äù: *Continue (regular output)*.

5. **Add node: If**
   - Node type: *If*
   - Conditions (AND):
     - `{{$json.title}}` exists
     - `{{$json.text || $json.translatedText}}` exists
     - `{{$json.subtitles[0].plaintext}}` exists
   - True path continues to extraction; False path skips to loop continuation.

6. **Add node: LLM model (4o mini)**
   - Node type: *OpenRouter Chat Model*
   - Model: `openai/gpt-4o-mini`
   - Temperature: `0.1`
   - Select OpenRouter credential.

7. **Add node: (Optional) LLM model (sonnet 3.5)**
   - Node type: *OpenRouter Chat Model*
   - Model: `anthropic/claude-3.5-sonnet`

8. **Add node: Structured Output Parser (Parseur)**
   - Node type: *Structured Output Parser*
   - Enable *Auto-fix*
   - Provide an example JSON with keys `topics`, `tools`, `concepts` (arrays of strings).

9. **Add node: LLM model for parser autofix (4.1 mini)**
   - Node type: *OpenRouter Chat Model*
   - Important: set an explicit model (to avoid default ambiguity), e.g. `openai/gpt-4o-mini` or another small model.
   - Connect it as the parser‚Äôs language model.

10. **Add node: LangChain Agent (Cat√©gorie d√©finition Agent)**
   - Node type: *Agent*
   - Prompt type: ‚Äúdefine‚Äù
   - Input text (compose):
     - `Titre : {{$json.title}}`
     - `Description : {{$json.text || $json.translatedText}}`
     - `Transcrit : {{$json.subtitles[0].plaintext}}`
   - System message: the extractor instructions (topics/tools/concepts; lowercase; max 15; JSON only).
   - Connect:
     - AI language model input(s): `4o mini` (and optionally `sonnet 3.5` as fallback)
     - Output parser: `Parseur`

11. **Add node: HTTP Request (Vers Neo4j)**
   - Node type: *HTTP Request*
   - Method: POST
   - URL: `https://<your_db_id>.databases.neo4j.io/db/neo4j/query/v2`
   - Authentication: *Generic credential type* ‚Üí *HTTP Header Auth* (your Neo4j credential)
   - Headers:
     - `Accept: application/json`
   - Body (JSON):
     - `statement`: Cypher MERGE/UNWIND to create `Video/Topic/Tool/Concept` and relationships
     - `parameters`: map scraped fields + extracted arrays
   - Set ‚ÄúOn Error‚Äù: *Continue (error output)* (optional, but matches provided workflow).

12. **Add node: Form (Results)**
   - Node type: *Form*
   - Operation: *Completion*
   - Title: `Votre deuxi√®me cerveau bas√© sur {{$json.channelName}} √† √©t√© cr√©√© avec succ√®s !`
   - Message: ‚ÄúTu peux maintenant discuter avec un Agent IA entrain√© sur le data de sa cha√Æne Youtube.‚Äù

### C) Wire the ingestion nodes (connection order)
1. `Form Trigger` ‚Üí `Get channel videos URLs`
2. `Get channel videos URLs` ‚Üí `loop each video`
3. `loop each video` ‚Üí `Scraping of each URLs`
4. `Scraping of each URLs` ‚Üí `If`
5. `If (true)` ‚Üí `Cat√©gorie d√©finition Agent`
6. `Cat√©gorie d√©finition Agent` ‚Üí `Vers Neo4j`
7. `Vers Neo4j` ‚Üí `loop each video` (to continue batches)
8. `If (false)` ‚Üí `loop each video` (skip this video)
9. (Optional but present in provided workflow) `loop each video` ‚Üí `Results` (completion screen)

**Recommended improvement:** connect `Results` only after the final batch completes (or after a separate ‚Äúdone‚Äù condition), so completion isn‚Äôt shown prematurely.

---

### D) Build the chat GraphRAG agent (Chat Trigger ‚Üí Agent ‚Üí Tool ‚Üí Response)
1. **Add node: Chat Trigger (When chat message received)**
   - Response mode: `responseNodes`

2. **Add node: OpenRouter Chat Model (4o)**
   - Model: `openai/chatgpt-4o-latest`
   - Temperature: `0.1`

3. **Add node: (Optional) OpenRouter Chat Model (sonnet 4.5)**

4. **Add node: Simple Memory**
   - Type: *Buffer Window Memory*
   - Context window length: `10`

5. **Add node: HTTP Request Tool (neo4j_query)**
   - Type: *HTTP Request Tool*
   - URL: Neo4j query endpoint `.../query/v2`
   - Method: POST
   - Auth: HTTP Header Auth (Neo4j)
   - Header: `Content-Type: application/json`
   - Body: JSON generated by the agent with key `statement`

6. **Add node: Agent (AI Agent)**
   - System message:
     - Include schema
     - Explain tool usage with `{"statement":"..."}` format
     - Enforce rules (toLower+CONTAINS, LIMIT 10, return title+url, markdown links, French)
   - Connect:
     - Main input from Chat Trigger
     - AI language model(s): `4o` (and `sonnet 4.5` optional)
     - Tool: `neo4j_query`
     - Memory: `Simple Memory`

7. **Add node: Respond to Chat**
   - Message: `{{$json.output}}`

### E) Wire the chat nodes
1. `When chat message received` ‚Üí `AI Agent`
2. `AI Agent` ‚Üí `Respond to Chat`
3. Connect `4o` (and optional `sonnet 4.5`) to `AI Agent` as AI language model inputs
4. Connect `neo4j_query` to `AI Agent` as AI tool
5. Connect `Simple Memory` to `AI Agent` as AI memory

---

## 5. General Notes & Resources

| Note Content | Context or Link |
|---|---|
| ‚ÄúMake sure you converted your username:password combination into a Base64 string.‚Äù | Used for Neo4j `Authorization: Basic ‚Ä¶` header auth |
| Base64 tool link | https://www.base64encode.org/ |
| Output expectations: knowledge graph + dashboards + chat | Dashboard preview images: https://bdcahdjartshknrvdnxq.supabase.co/storage/v1/object/public/gpt-images/neo4j_dash_1.png and https://bdcahdjartshknrvdnxq.supabase.co/storage/v1/object/public/gpt-images/neo4j-dash-2.png |
| Setup summary from canvas note: create Neo4j Aura, configure header auth, run ingestion, test via chat | Applies to entire solution |

Disclaimer (as provided):  
Le texte fourni provient exclusivement d‚Äôun workflow automatis√© r√©alis√© avec n8n, un outil d‚Äôint√©gration et d‚Äôautomatisation. Ce traitement respecte strictement les politiques de contenu en vigueur et ne contient aucun √©l√©ment ill√©gal, offensant ou prot√©g√©. Toutes les donn√©es manipul√©es sont l√©gales et publiques.