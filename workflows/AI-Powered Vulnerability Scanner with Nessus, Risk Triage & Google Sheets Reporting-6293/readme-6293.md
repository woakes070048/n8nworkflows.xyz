AI-Powered Vulnerability Scanner with Nessus, Risk Triage & Google Sheets Reporting

https://n8nworkflows.xyz/workflows/ai-powered-vulnerability-scanner-with-nessus--risk-triage---google-sheets-reporting-6293


# AI-Powered Vulnerability Scanner with Nessus, Risk Triage & Google Sheets Reporting

### 1. Workflow Overview

This workflow, titled **AI-Powered Vulnerability Scanner with Nessus, Risk Triage & Google Sheets Reporting**, automates vulnerability scanning using the Nessus API, applies AI-driven risk evaluation and triage, generates alerts for critical vulnerabilities, and exports summarized results to Google Sheets with email reporting. It is designed for security teams to enhance their vulnerability management process with AI risk scoring, structured triage, and compliance-aligned reporting.

The workflow logically divides into these blocks:

- **1.1 Trigger & Authentication:** Scheduled trigger initiates the scan and authenticates to the Nessus API.
- **1.2 Discovery Phase:** Initializes network segments and discovers assets in scope.
- **1.3 AI Processing:** Processes asset data and prepares it for scanning.
- **1.4 Scanning Phase:** Splits assets, runs Nessus scans, and processes vulnerability findings.
- **1.5 AI Risk Evaluation & Triage:** Applies AI logic to evaluate risk scores and categorize vulnerabilities.
- **1.6 Alerting:** Triggers alerts for critical vulnerabilities based on risk evaluation.
- **1.7 Reporting & Export:** Generates summary reports, emails them, and saves data to Google Sheets.
- **1.8 Error Handling:** Captures errors, sanitizes messages, logs them to Google Sheets, and manages failure flow.

---

### 2. Block-by-Block Analysis

#### 1.1 Trigger & Authentication

- **Overview:** Initiates workflow on a scheduled basis and logs into Nessus to obtain an API session token.
- **Nodes Involved:**  
  - `‚è±Ô∏è Trigger ‚Äì Scheduled Scan`  
  - `üîê AUTH ‚Äì Login to Nessus`  
  - `üîê AUTH ‚Äì Set API Token`

- **Node Details:**

  - **‚è±Ô∏è Trigger ‚Äì Scheduled Scan**  
    - *Type:* Schedule Trigger  
    - *Role:* Triggers workflow daily at 07:00 AM (Australia/Sydney timezone) using a cron expression.  
    - *Input/Output:* No input; outputs trigger event to Login node.  
    - *Failures:* Cron misconfiguration or scheduler downtime.

  - **üîê AUTH ‚Äì Login to Nessus**  
    - *Type:* HTTP Request  
    - *Role:* Authenticates to Nessus API using username and password from environment variables.  
    - *Configuration:* POST request to `${NESSUS_API_URL}/session` with JSON body containing credentials.  
    - *Output:* Full HTTP response including headers used for session cookies.  
    - *Failures:* Auth failure, API unreachable, invalid credentials, or TLS issues (allowUnauthorizedCerts enabled).  

  - **üîê AUTH ‚Äì Set API Token**  
    - *Type:* Set Node  
    - *Role:* Extracts and stores the Nessus API session token ("X-Cookie") from the login response headers for subsequent requests.  
    - *Key Expression:* Parses `set-cookie` header to extract the token.  
    - *Failures:* Missing or malformed cookie header, parsing errors.

---

#### 1.2 Discovery Phase

- **Overview:** Prepares network segment data and discovers assets via Nessus API.
- **Nodes Involved:**  
  - `üåê DISC ‚Äì Initialize Network Segments`  
  - `üåê DISC ‚Äì Discover Assets`  
  - `üß† AI ‚Äì Process Assets`

- **Node Details:**

  - **üåê DISC ‚Äì Initialize Network Segments**  
    - *Type:* Function  
    - *Role:* Loads network segments/subnets from an environment variable `NETWORK_SEGMENTS` (JSON array) into workflow data for asset discovery.  
    - *Failures:* Invalid or empty environment variable causing empty segments.

  - **üåê DISC ‚Äì Discover Assets**  
    - *Type:* HTTP Request  
    - *Role:* Queries Nessus API endpoint `/scans` to retrieve scan and asset information.  
    - *Headers:* Uses `X-Cookie` token from previous step for authentication.  
    - *Failures:* API errors, token expiration, or network issues.

  - **üß† AI ‚Äì Process Assets**  
    - *Type:* Function  
    - *Role:* Converts raw asset data into a structured format for scanning. In this example, static asset data is returned for demonstration.  
    - *Output:* JSON array with assets including id, IP address, and hostname.  
    - *Failures:* Logic errors or empty asset arrays.

---

#### 1.3 AI Processing & Utilities

- **Overview:** Prepares the assets for scanning by splitting the asset list for iterative processing.
- **Nodes Involved:**  
  - `üîÑ UTILS ‚Äì Split Assets`

- **Node Details:**

  - **üîÑ UTILS ‚Äì Split Assets**  
    - *Type:* SplitOut  
    - *Role:* Splits the array of assets into individual items to allow per-asset scanning in parallel or sequence.  
    - *Input:* Asset list from AI processing.  
    - *Output:* Individual asset objects for scanning.  
    - *Failures:* Empty or malformed asset list.

---

#### 1.4 Scanning Phase

- **Overview:** Runs Nessus scans for each asset and processes the resulting vulnerability data.
- **Nodes Involved:**  
  - `üß™ SCAN ‚Äì Run Nessus`  
  - `üîç SCAN ‚Äì Process Vulnerabilities`

- **Node Details:**

  - **üß™ SCAN ‚Äì Run Nessus**  
    - *Type:* HTTP Request  
    - *Role:* Initiates a Nessus scan for each asset using its IP address or hostname.  
    - *Configuration:* POST to `/scans` with scan UUID, scan name including host info, target IP, and folder ID; launches scan immediately.  
    - *Authentication:* Uses `X-Cookie` token.  
    - *Failures:* API errors, invalid scan parameters, token issues, or API downtime.

  - **üîç SCAN ‚Äì Process Vulnerabilities**  
    - *Type:* Function  
    - *Role:* Parses scan results to extract vulnerability details. In the sample, static vulnerability data is returned.  
    - *Output:* Array of vulnerabilities with fields like ID, CVE, risk level, and associated IP.  
    - *Failures:* Parsing issues, empty or malformed scan results.

---

#### 1.5 AI Risk Evaluation & Triage

- **Overview:** Applies AI logic to assign risk scores and triage vulnerabilities into different handling groups.
- **Nodes Involved:**  
  - `ü§ñ AI ‚Äì Risk Evaluation`  
  - `üìä AI ‚Äì Triage Vulnerabilities`

- **Node Details:**

  - **ü§ñ AI ‚Äì Risk Evaluation**  
    - *Type:* Function  
    - *Role:* Assigns AI-generated risk metrics (e.g., AI risk score, LEV score, remediation path) to vulnerabilities.  
    - *Logic:* Maps sample risk scores and paths with fallback defaults.  
    - *Output:* Enriched vulnerability objects with AI scores.  
    - *Failures:* Logic errors, empty input data.

  - **üìä AI ‚Äì Triage Vulnerabilities**  
    - *Type:* Function  
    - *Role:* Categorizes vulnerabilities into three groups based on LEV score thresholds:  
      - LEV > 0.9: Expert group (Critical)  
      - LEV > 0.5: Self-managed group (High)  
      - Otherwise: Monitor group (Low)  
    - *Output:* Object containing arrays for each triage group.  
    - *Failures:* Missing LEV scores, improper input format.

---

#### 1.6 Alerting

- **Overview:** Checks if critical vulnerabilities exist and triggers alerts accordingly.
- **Nodes Involved:**  
  - `üö¶ ALERT ‚Äì LEV Trigger`  
  - `üìß Alert Security Team`

- **Node Details:**

  - **üö¶ ALERT ‚Äì LEV Trigger**  
    - *Type:* If Node  
    - *Role:* Evaluates if there are any vulnerabilities in the expert group (LEV > 0.9).  
    - *Condition:* Checks if `expert` array length is greater than zero.  
    - *Output:*  
      - True: Sends alert email.  
      - False: Proceeds to reporting.  
    - *Failures:* Expression evaluation errors or missing triage data.

  - **üìß Alert Security Team**  
    - *Type:* Email Send  
    - *Role:* Sends critical vulnerability alert email to the security team.  
    - *Configuration:* HTML email with embedded timestamp, workflow name, and alert details.  
    - *Failures:* SMTP connection issues, invalid email addresses.

---

#### 1.7 Reporting & Export

- **Overview:** Generates vulnerability assessment summary reports, emails them, and exports data to Google Sheets.
- **Nodes Involved:**  
  - `üìù REPORT ‚Äì Generate Summary`  
  - `üõ†Ô∏è UTILS ‚Äì Field Editor`  
  - `Code`  
  - `üìÑ EXPORT ‚Äì Save to Sheet`  
  - `Send Email`

- **Node Details:**

  - **üìù REPORT ‚Äì Generate Summary**  
    - *Type:* Function  
    - *Role:* Aggregates triaged vulnerability data to compute counts per group, total findings, max LEV score, and identifies top CVE.  
    - *Output:* Summary object including email body HTML for reporting.  
    - *Failures:* Missing triage data or miscalculations.

  - **üõ†Ô∏è UTILS ‚Äì Field Editor**  
    - *Type:* Set Node  
    - *Role:* Formats grouped vulnerability data into an array for downstream processing/export.  
    - *Output:* Sets `groupData` field with timestamped counts for each triage group.  
    - *Failures:* Format errors or empty input.

  - **Code**  
    - *Type:* Code Node (JavaScript)  
    - *Role:* Maps `groupData` array elements into individual items for sheet appending.  
    - *Failures:* JS syntax or mapping errors.

  - **üìÑ EXPORT ‚Äì Save to Sheet**  
    - *Type:* Google Sheets  
    - *Role:* Appends the summary report data to a Google Sheets document (sheet named "summary").  
    - *Credentials:* Uses configured Google Sheets OAuth2 credentials.  
    - *Failures:* API quota limits, credential expiration, or sheet access issues.

  - **Send Email**  
    - *Type:* Email Send  
    - *Role:* Sends the vulnerability assessment report email to the security team.  
    - *Failures:* SMTP issues as above.

---

#### 1.8 Error Handling

- **Overview:** Captures workflow errors, sanitizes sensitive information, logs errors to Google Sheets.
- **Nodes Involved:**  
  - ` ERROR ‚Äì On Failure`  
  - `üõ†Ô∏è UTILS ‚Äì Set Grouped Data`  
  - `Code1`  
  - `üìÑ EXPORT ‚Äì Sheet Append`

- **Node Details:**

  - ** ERROR ‚Äì On Failure**  
    - *Type:* Error Trigger  
    - *Role:* Listens for workflow errors to start error processing.  
    - *Output:* Passes error info to Set Grouped Data node.  
    - *Failures:* None (this is the error handler itself).

  - **üõ†Ô∏è UTILS ‚Äì Set Grouped Data**  
    - *Type:* Set Node  
    - *Role:* Structures error details including timestamp, workflow name, node name, and error message.  
    - *Failures:* Missing error context.

  - **Code1**  
    - *Type:* Code Node (JavaScript)  
    - *Role:* Sanitizes error message by redacting IPs, emails, API keys, and URLs to prevent sensitive data leaks.  
    - *Failures:* Regex or string manipulation errors.

  - **üìÑ EXPORT ‚Äì Sheet Append**  
    - *Type:* Google Sheets  
    - *Role:* Appends sanitized error log entry to an error log sheet in the same Google Sheets document.  
    - *Failures:* Same as Export node above.

---

### 3. Summary Table

| Node Name                      | Node Type            | Functional Role                         | Input Node(s)                    | Output Node(s)                      | Sticky Note                                                                                 |
|--------------------------------|----------------------|--------------------------------------|---------------------------------|-----------------------------------|---------------------------------------------------------------------------------------------|
| ‚è±Ô∏è Trigger ‚Äì Scheduled Scan     | Schedule Trigger     | Initiates workflow on schedule       | -                               | üîê AUTH ‚Äì Login to Nessus          | ‚è±Ô∏è Trigger ‚Äì Scheduled Scan            Trigger scan daily/weekly                         |
| üîê AUTH ‚Äì Login to Nessus        | HTTP Request        | Authenticates to Nessus API          | ‚è±Ô∏è Trigger ‚Äì Scheduled Scan       | üîê AUTH ‚Äì Set API Token            | üîê AUTH ‚Äì Login to Nessus        Login to scanner API                              |
| üîê AUTH ‚Äì Set API Token          | Set                 | Extracts API token from login response| üîê AUTH ‚Äì Login to Nessus         | üåê DISC ‚Äì Initialize Network Segments | üîê AUTH ‚Äì Set API Token                Store token securely for session                     |
| üåê DISC ‚Äì Initialize Network Segments | Function            | Loads network segments from env var  | üîê AUTH ‚Äì Set API Token           | üåê DISC ‚Äì Discover Assets          | üåê Discovery Phase                                                                     |
| üåê DISC ‚Äì Discover Assets        | HTTP Request        | Retrieves assets via Nessus API      | üåê DISC ‚Äì Initialize Network Segments | üß† AI ‚Äì Process Assets             | üåê Discovery Phase                                                                     |
| üß† AI ‚Äì Process Assets           | Function            | Processes asset list for scanning    | üåê DISC ‚Äì Discover Assets          | üîÑ UTILS ‚Äì Split Assets            | üåê Discovery Phase                                                                     |
| üîÑ UTILS ‚Äì Split Assets          | SplitOut            | Splits asset array into individual items | üß† AI ‚Äì Process Assets             | üß™ SCAN ‚Äì Run Nessus              | üß™ SCAN Phase                                                                         |
| üß™ SCAN ‚Äì Run Nessus             | HTTP Request        | Launches vulnerability scan          | üîÑ UTILS ‚Äì Split Assets            | üîç SCAN ‚Äì Process Vulnerabilities | üß™ SCAN Phase                                                                         |
| üîç SCAN ‚Äì Process Vulnerabilities| Function            | Parses vulnerability scan results    | üß™ SCAN ‚Äì Run Nessus               | ü§ñ AI ‚Äì Risk Evaluation           | üß™ SCAN Phase                                                                         |
| ü§ñ AI ‚Äì Risk Evaluation          | Function            | Assigns AI risk scores to vulnerabilities | üîç SCAN ‚Äì Process Vulnerabilities  | üìä AI ‚Äì Triage Vulnerabilities    | üß† AI Calculate Risk phase                                                             |
| üìä AI ‚Äì Triage Vulnerabilities   | Function            | Categorizes vulnerabilities by risk  | ü§ñ AI ‚Äì Risk Evaluation            | üö¶ ALERT ‚Äì LEV Trigger, üõ†Ô∏è UTILS ‚Äì Field Editor | ‚ö†Ô∏è RESPOND ‚Äî Risk Intelligence & Alerts                                                 |
| üö¶ ALERT ‚Äì LEV Trigger           | If                  | Checks for critical vulnerabilities  | üìä AI ‚Äì Triage Vulnerabilities     | üìß Alert Security Team, üìù REPORT ‚Äì Generate Summary | ‚ö†Ô∏è RESPOND ‚Äî Risk Intelligence & Alerts                                                 |
| üìß Alert Security Team           | Email Send          | Sends alert email for critical issues| üö¶ ALERT ‚Äì LEV Trigger (true path) | -                                 | üö® ALERT \nüìä REPORT phase                                                             |
| üìù REPORT ‚Äì Generate Summary     | Function            | Creates summary report and email body| üö¶ ALERT ‚Äì LEV Trigger (false path) | Send Email, üìÑ EXPORT ‚Äì Save to Sheet | üîÅ RECOVER ‚Äî Reporting & Remediation Support                                           |
| üõ†Ô∏è UTILS ‚Äì Field Editor          | Set                 | Formats grouped triage data for export| üìä AI ‚Äì Triage Vulnerabilities    | Code                             | üîÅ RECOVER ‚Äî Reporting & Remediation Support                                           |
| Code                           | Code                 | Splits group data array for export   | üõ†Ô∏è UTILS ‚Äì Field Editor            | üìÑ EXPORT ‚Äì Save to Sheet         | üîÅ RECOVER ‚Äî Reporting & Remediation Support                                           |
| üìÑ EXPORT ‚Äì Save to Sheet        | Google Sheets       | Appends summary data to Google Sheets| Code                            | -                               | üîÅ RECOVER ‚Äî Reporting & Remediation Support                                           |
| Send Email                     | Email Send           | Sends vulnerability assessment email | üìù REPORT ‚Äì Generate Summary       | -                               | üîÅ RECOVER ‚Äî Reporting & Remediation Support                                           |
| ERROR ‚Äì On Failure               | Error Trigger       | Catches workflow errors              | -                               | üõ†Ô∏è UTILS ‚Äì Set Grouped Data       | Error Handling                                                                         |
| üõ†Ô∏è UTILS ‚Äì Set Grouped Data      | Set                 | Structures error information         | ERROR ‚Äì On Failure                | Code1                           | Error Handling                                                                         |
| Code1                          | Code                 | Sanitizes error messages             | üõ†Ô∏è UTILS ‚Äì Set Grouped Data       | üìÑ EXPORT ‚Äì Sheet Append          | Error Handling                                                                         |
| üìÑ EXPORT ‚Äì Sheet Append         | Google Sheets       | Logs sanitized error data to Sheets  | Code1                           | -                               | Error Handling                                                                         |

---

### 4. Reproducing the Workflow from Scratch

1. **Create Schedule Trigger Node**  
   - Type: Schedule Trigger  
   - Cron Expression: `0 0 7 * * *` (runs daily at 7 AM)  
   - Connect output to "Login to Nessus" node.

2. **Create HTTP Request Node: Login to Nessus**  
   - URL: `${NESSUS_API_URL}/session` (use environment variable)  
   - Method: POST  
   - Body Type: JSON  
   - Body: `{ "username": "{{ $env.NESSUS_USER }}", "password": "{{ $env.NESSUS_PASS }}" }`  
   - Enable `Allow Unauthorized Certs` if needed.  
   - Connect output to "Set API Token" node.

3. **Create Set Node: Set API Token**  
   - Create new field `X-Cookie`  
   - Value: Extract first cookie token from login response headers:  
     `={{ $('üîê AUTH ‚Äì Login to Nessus').item.headers['set-cookie'][0].split(';')[0] }}`  
   - Connect output to "Initialize Network Segments".

4. **Create Function Node: Initialize Network Segments**  
   - Code:  
     ```javascript
     const networkSegments = JSON.parse($env.NETWORK_SEGMENTS || '[]');
     return { json: { networkSegments } };
     ```  
   - Connect output to "Discover Assets".

5. **Create HTTP Request Node: Discover Assets**  
   - URL: `https://localhost:8834/scans` (adjust for your Nessus API endpoint)  
   - Method: GET (default)  
   - Headers: `X-Cookie` with value `={{ 'token=' + $('üîê AUTH ‚Äì Set API Token').item.json.body.token }}` (adjust if necessary)  
   - Enable `Allow Unauthorized Certs` if needed.  
   - Connect output to "Process Assets".

6. **Create Function Node: Process Assets**  
   - Code (example static data):  
     ```javascript
     return {
       json: {
         assets: [
           { id: "asset-001", ipAddress: "10.0.0.1", hostName: "host-a" },
           { id: "asset-002", ipAddress: "10.0.0.2", hostName: "host-b" }
         ]
       }
     };
     ```  
   - Connect output to "Split Assets".

7. **Create SplitOut Node: Split Assets**  
   - Field to split out: `assets`  
   - Connect output to "Run Nessus".

8. **Create HTTP Request Node: Run Nessus Scan**  
   - URL: `${NESSUS_API_URL}/scans`  
   - Method: POST  
   - Body Type: JSON  
   - Body:  
     ```json
     {
       "uuid": "{{ $env.NESSUS_SCAN_UUID }}",
       "settings": {
         "name": "Scan ‚Äì {{ $json.hostName || $json.ipAddress }}",
         "text_targets": "{{ $json.ipAddress }}",
         "folder_id": 3,
         "launch_now": true
       }
     }
     ```  
   - Headers: `X-Cookie` from `{{ $('AUTH ‚Äì Set API Token').json['X-Cookie'] }}`  
   - Enable `Allow Unauthorized Certs`.  
   - Connect output to "Process Vulnerabilities".

9. **Create Function Node: Process Vulnerabilities**  
   - Example static data:  
     ```javascript
     return {
       json: {
         vulnerabilities: [
           { id: "vuln-001", cve: "CVE-2023-1234", risk: "High", ip: "10.0.0.1" }
         ]
       }
     };
     ```  
   - Connect output to "Risk Evaluation".

10. **Create Function Node: Risk Evaluation**  
    - Code:  
      ```javascript
      const vulns = $json.vulnerabilities;
      return vulns.map((v, i) => ({
        json: {
          ...v,
          aiRisk: [6.5, 9.1][i] || 5,
          path: ["self-healing", "expert-review", "monitoring"][i % 3],
          lev: [0.93, 0.72][i] || 0.45
        }
      }));
      ```  
    - Connect output to "Triage Vulnerabilities".

11. **Create Function Node: Triage Vulnerabilities**  
    - Code:  
      ```javascript
      const triage = { self: [], expert: [], monitor: [] };
      const assessed = $input.all();
      for (const item of assessed) {
        const v = item.json;
        const levScore = v.lev || 0;
        if (levScore > 0.9) triage.expert.push({ ...v, levScore, levLabel: "Critical" });
        else if (levScore > 0.5) triage.self.push({ ...v, levScore, levLabel: "High" });
        else triage.monitor.push({ ...v, levScore, levLabel: "Low" });
      }
      return [{ json: triage }];
      ```  
    - Connect output to "LEV Trigger" and "Field Editor".

12. **Create If Node: ALERT ‚Äì LEV Trigger**  
    - Condition: Check if `{{ $json.expert && $json.expert.length > 0 }}` equals `"true"`  
    - True branch: Connect to "Alert Security Team" email node.  
    - False branch: Connect to "Generate Summary".

13. **Create Email Send Node: Alert Security Team**  
    - To: `security_team@example.com`  
    - From: `your_email@example.com`  
    - Subject: `Alert`  
    - HTML Body:  
      ```html
      <h2>üö® Critical Vulnerability Alert!</h2>
      <p>One or more vulnerabilities with an <strong>AI Risk Score ‚â• 8</strong> were detected in the latest scan.</p>
      <p>Please review them immediately in the <strong>CyberPulse</strong> report or dashboard.</p>
      <p>Triggered by: {{ $workflow.name }}<br>Timestamp: {{ new Date().toISOString() }}</p>
      <p>Stay secure,<br><em>n8n - CyberPulse Automation</em></p>
      ```  
    - Use SMTP credentials configured for your mail server.

14. **Create Function Node: Generate Summary**  
    - Code:  
      ```javascript
      const triage = $json;
      const all = [...triage.expert, ...triage.self, ...triage.monitor];
      const maxLEV = Math.max(...all.map(v => v.lev || 0));
      const topCVE = triage.expert[0]?.cve || triage.self[0]?.cve || triage.monitor[0]?.cve || "None";
      return {
        summary: {
          expert: triage.expert.length,
          self: triage.self.length,
          monitor: triage.monitor.length,
          total: all.length,
          timestamp: new Date().toISOString(),
          topCVE,
          maxLEV
        },
        emailBody: `
          <h2>üîç Vulnerability Assessment Report</h2>
          <p><strong>üìÖ Timestamp:</strong> ${new Date().toISOString()}</p>
          <ul>
            <li><strong>üë®‚Äçüíª Expert Group:</strong> ${triage.expert.length}</li>
            <li><strong>üß™ Self Group:</strong> ${triage.self.length}</li>
            <li><strong>üìä Monitor Group:</strong> ${triage.monitor.length}</li>
            <li><strong>üö® Max LEV Score:</strong> ${maxLEV}</li>
            <li><strong>üí° Top CVE:</strong> ${topCVE}</li>
          </ul>
        `
      };
      ```  
    - Connect output to "Send Email" and "Save to Sheet".

15. **Create Set Node: Field Editor**  
    - Assign field `groupData` as an array with objects containing `timestamp`, `group`, and `count` for each triage group, extracted from input JSON.  
    - Connect output to "Code".

16. **Create Code Node: Code**  
    - Code:  
      ```javascript
      return items[0].json.groupData.map(obj => ({ json: obj }));
      ```  
    - Connect output to "Save to Sheet".

17. **Create Google Sheets Node: Save to Sheet**  
    - Operation: Append  
    - Document ID and Sheet Name: Set per your Google Sheets document (e.g., summary sheet gid=0).  
    - Fields: Map `timestamp`, `self`, `expert`, `monitor`, `total`, `topCVE`, `maxLEV` from summary JSON.  
    - Credentials: Configure with Google Sheets OAuth2.  

18. **Create Email Send Node: Send Email**  
    - To: `security_team@example.com`  
    - From: `your_email@example.com`  
    - Subject: `üõ° Vulnerability Assessment report`  
    - HTML Body: `={{ $json.emailBody }}` (from summary node)  
    - Credentials: SMTP account.

19. **Create Error Trigger Node: ERROR ‚Äì On Failure**  
    - Connect output to "Set Grouped Data".

20. **Create Set Node: UTILS ‚Äì Set Grouped Data**  
    - Assign fields: timestamp (current ISO string), workflow name, error node name, error message.  
    - Connect output to "Code1".

21. **Create Code Node: Code1**  
    - Code:  
      ```javascript
      const msg = $json["error message"] || "";
      const sanitized = msg
        .replace(/\b\d{1,3}(\.\d{1,3}){3}\b/g, '***.***.***.***')
        .replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g, '[email]')
        .replace(/apikey=\w+/gi, 'apikey=[redacted]')
        .replace(/https:\/\/[^\s]+/g, 'https://[url]');
      return [{ json: {
        timestamp: $json["timestamp"],
        workflow: $json["workflow"],
        node: $json["node"],
        "error message": sanitized
      }}];
      ```  
    - Connect output to "Sheet Append".

22. **Create Google Sheets Node: Sheet Append**  
    - Operation: Append  
    - Document ID and Sheet Name: Point to error log sheet in same Google Sheets doc.  
    - Map fields: timestamp, workflow, node, error message.  
    - Credentials: Google Sheets OAuth2.

---

### 5. General Notes & Resources

| Note Content                                                                                                                                                                                                                                                                                                                                  | Context or Link                                                                                              |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| Workflow structured and visually annotated to align with NIST Cybersecurity Framework (Identify, Protect, Detect, Respond, Recover) for compliance and audit readiness.                                                                                                                                                                        | Sticky notes inside workflow                                                                                 |
| LEV (Likely Exploited Vulnerabilities) metric is used to enhance risk prioritization beyond traditional EPSS, aligning with federal mandates such as BOD 22-01 and KEV compliance.                                                                                                                                                            | Sticky Note8 and Glossary (Sticky Note16)                                                                    |
| Workflow demonstrates integration with Nessus API, AI evaluation logic, automated alerting via email, and data export to Google Sheets for documentation and reporting.                                                                                                                                                                      | Overall workflow description                                                                                 |
| Error handling includes sanitization of sensitive data (IP addresses, emails, API keys, URLs) before logging to Google Sheets to comply with security best practices.                                                                                                                                                                       | Error Handling block                                                                                          |
| Google Sheets document IDs and sheet names are placeholders; replace with actual document IDs and sheet GIDs in your environment.                                                                                                                                                                                                           | Export nodes configuration                                                                                    |
| SMTP and Google Sheets credentials must be configured in n8n prior to workflow execution.                                                                                                                                                                                                                                                    | Credential references in email and Google Sheets nodes                                                       |
| For detailed NIST CSF and LEV information, review NIST CSWP 41 paper and CISA directives (BOD 22-01, KEV catalog).                                                                                                                                                                                                                           | Sticky Note14 and Sticky Note16 glossary terms                                                               |
| The workflow is designed for on-premises or secure network environments where Nessus API is accessible and environment variables for credentials and network segments are securely stored.                                                                                                                                                    | Best practices for environment variables and API security                                                   |

---

**Disclaimer:** This documentation is based exclusively on an n8n automated workflow. It complies strictly with content policies and contains no illegal or protected elements. All processed data is legal and publicly accessible.